<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>4 Coefficients | Structural Equation Modeling in R for Ecology and Evolution</title>
  <meta name="description" content="4 Coefficients | Structural Equation Modeling in R for Ecology and Evolution" />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="4 Coefficients | Structural Equation Modeling in R for Ecology and Evolution" />
  <meta property="og:type" content="book" />
  
  
  
  <meta name="github-repo" content="jslefche/sem_book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="4 Coefficients | Structural Equation Modeling in R for Ecology and Evolution" />
  
  
  

<meta name="author" content="Jonathan Lefcheck" />


<meta name="date" content="2021-01-16" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="local-estimation.html"/>
<link rel="next" href="categorical-variables.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Preface</a></li>
<li class="chapter" data-level="2" data-path="global-estimation.html"><a href="global-estimation.html"><i class="fa fa-check"></i><b>2</b> Global Estimation</a><ul>
<li class="chapter" data-level="2.1" data-path="global-estimation.html"><a href="global-estimation.html#what-is-covariance"><i class="fa fa-check"></i><b>2.1</b> What is (Co)variance?</a></li>
<li class="chapter" data-level="2.2" data-path="global-estimation.html"><a href="global-estimation.html#regression-coefficients"><i class="fa fa-check"></i><b>2.2</b> Regression Coefficients</a><ul>
<li class="chapter" data-level="2.2.1" data-path="global-estimation.html"><a href="global-estimation.html#rule-1-unspecified-relationships-among-exogenous-variables-are-simply-their-bivariate-correlations."><i class="fa fa-check"></i><b>2.2.1</b> Rule 1: Unspecified relationships among exogenous variables are simply their bivariate correlations.</a></li>
<li class="chapter" data-level="2.2.2" data-path="global-estimation.html"><a href="global-estimation.html#rule-2-when-two-variables-are-connected-by-a-single-path-the-coefficient-of-that-path-is-the-regression-coefficient."><i class="fa fa-check"></i><b>2.2.2</b> Rule 2: When two variables are connected by a single path, the coefficient of that path is the regression coefficient.</a></li>
<li class="chapter" data-level="2.2.3" data-path="global-estimation.html"><a href="global-estimation.html#rule-3-the-strength-of-a-compound-path-one-that-includes-multiple-links-is-the-product-of-the-individual-coefficients."><i class="fa fa-check"></i><b>2.2.3</b> Rule 3: The strength of a compound path (one that includes multiple links) is the product of the individual coefficients.</a></li>
<li class="chapter" data-level="2.2.4" data-path="global-estimation.html"><a href="global-estimation.html#rule-4.-when-variables-are-connected-by-more-than-one-pathway-each-pathway-is-the-partial-regression-coefficient."><i class="fa fa-check"></i><b>2.2.4</b> Rule 4. When variables are connected by more than one pathway, each pathway is the ‘partial’ regression coefficient.</a></li>
<li class="chapter" data-level="2.2.5" data-path="global-estimation.html"><a href="global-estimation.html#rule-5-errors-on-endogenous-variables-relate-the-unexplained-correlations-or-variances-arising-from-unmeasured-variables."><i class="fa fa-check"></i><b>2.2.5</b> Rule 5: Errors on endogenous variables relate the unexplained correlations or variances arising from unmeasured variables.</a></li>
<li class="chapter" data-level="2.2.6" data-path="global-estimation.html"><a href="global-estimation.html#rule-6-unanalyzed-residual-correlations-among-two-endogenous-variables-are-their-partial-correlations."><i class="fa fa-check"></i><b>2.2.6</b> Rule 6: Unanalyzed (residual) correlations among two endogenous variables are their partial correlations.</a></li>
<li class="chapter" data-level="2.2.7" data-path="global-estimation.html"><a href="global-estimation.html#rule-7-the-total-effect-one-variable-has-another-is-the-sum-of-its-direct-and-indirect-effects."><i class="fa fa-check"></i><b>2.2.7</b> Rule 7: The total effect one variable has another is the sum of its direct and indirect effects.</a></li>
<li class="chapter" data-level="2.2.8" data-path="global-estimation.html"><a href="global-estimation.html#rule-8-the-total-effect-including-undirected-paths-is-equivalent-to-the-total-correlation."><i class="fa fa-check"></i><b>2.2.8</b> Rule 8: The total effect (including undirected paths) is equivalent to the total correlation.</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="global-estimation.html"><a href="global-estimation.html#variance-based-structural-equation-modeling"><i class="fa fa-check"></i><b>2.3</b> Variance-based Structural Equation Modeling</a></li>
<li class="chapter" data-level="2.4" data-path="global-estimation.html"><a href="global-estimation.html#model-identifiability"><i class="fa fa-check"></i><b>2.4</b> Model Identifiability</a></li>
<li class="chapter" data-level="2.5" data-path="global-estimation.html"><a href="global-estimation.html#goodness-of-fit-measures"><i class="fa fa-check"></i><b>2.5</b> Goodness-of-fit Measures</a></li>
<li class="chapter" data-level="2.6" data-path="global-estimation.html"><a href="global-estimation.html#model-fitting-using-lavaan"><i class="fa fa-check"></i><b>2.6</b> Model Fitting Using <em>lavaan</em></a><ul>
<li class="chapter" data-level="2.6.1" data-path="global-estimation.html"><a href="global-estimation.html#lavaan-vs-lm"><i class="fa fa-check"></i><b>2.6.1</b> <em>lavaan</em> vs <code>lm</code></a></li>
<li class="chapter" data-level="2.6.2" data-path="global-estimation.html"><a href="global-estimation.html#sem-using-lavaan"><i class="fa fa-check"></i><b>2.6.2</b> SEM using <em>lavaan</em></a></li>
<li class="chapter" data-level="2.6.3" data-path="global-estimation.html"><a href="global-estimation.html#testing-alternative-structures-using-lavaan"><i class="fa fa-check"></i><b>2.6.3</b> Testing Alternative Structures using <em>lavaan</em></a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="global-estimation.html"><a href="global-estimation.html#references"><i class="fa fa-check"></i><b>2.7</b> References</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="local-estimation.html"><a href="local-estimation.html"><i class="fa fa-check"></i><b>3</b> Local Estimation</a><ul>
<li class="chapter" data-level="3.1" data-path="local-estimation.html"><a href="local-estimation.html#global-vs.-local-estimation"><i class="fa fa-check"></i><b>3.1</b> Global vs. local estimation</a></li>
<li class="chapter" data-level="3.2" data-path="local-estimation.html"><a href="local-estimation.html#tests-of-directed-separation"><i class="fa fa-check"></i><b>3.2</b> Tests of directed separation</a></li>
<li class="chapter" data-level="3.3" data-path="local-estimation.html"><a href="local-estimation.html#a-log-likelihood-approach-to-assessing-model-fit"><i class="fa fa-check"></i><b>3.3</b> A Log-Likelihood Approach to Assessing Model Fit</a></li>
<li class="chapter" data-level="3.4" data-path="local-estimation.html"><a href="local-estimation.html#model-fitting-using-piecewisesem"><i class="fa fa-check"></i><b>3.4</b> Model fitting using <em>piecewiseSEM</em></a></li>
<li class="chapter" data-level="3.5" data-path="local-estimation.html"><a href="local-estimation.html#extensions-to-generalized-mixed-effects-models"><i class="fa fa-check"></i><b>3.5</b> Extensions to Generalized Mixed Effects Models</a></li>
<li class="chapter" data-level="3.6" data-path="local-estimation.html"><a href="local-estimation.html#extensions-to-non-linear-models"><i class="fa fa-check"></i><b>3.6</b> Extensions to Non-linear Models</a></li>
<li class="chapter" data-level="3.7" data-path="local-estimation.html"><a href="local-estimation.html#a-special-case-where-graph-theory-fails"><i class="fa fa-check"></i><b>3.7</b> A Special Case: Where Graph Theory Fails</a></li>
<li class="chapter" data-level="3.8" data-path="local-estimation.html"><a href="local-estimation.html#references-1"><i class="fa fa-check"></i><b>3.8</b> References</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="coefficients.html"><a href="coefficients.html"><i class="fa fa-check"></i><b>4</b> Coefficients</a><ul>
<li class="chapter" data-level="4.1" data-path="coefficients.html"><a href="coefficients.html#unstandardized-and-standardized-coefficients"><i class="fa fa-check"></i><b>4.1</b> Unstandardized and Standardized Coefficients</a></li>
<li class="chapter" data-level="4.2" data-path="coefficients.html"><a href="coefficients.html#scale-standardization"><i class="fa fa-check"></i><b>4.2</b> Scale Standardization</a></li>
<li class="chapter" data-level="4.3" data-path="coefficients.html"><a href="coefficients.html#range-standardization"><i class="fa fa-check"></i><b>4.3</b> Range Standardization</a></li>
<li class="chapter" data-level="4.4" data-path="coefficients.html"><a href="coefficients.html#binomial-response-models"><i class="fa fa-check"></i><b>4.4</b> Binomial Response Models</a><ul>
<li class="chapter" data-level="4.4.1" data-path="coefficients.html"><a href="coefficients.html#latent-theoretic-approach"><i class="fa fa-check"></i><b>4.4.1</b> Latent Theoretic Approach</a></li>
<li class="chapter" data-level="4.4.2" data-path="coefficients.html"><a href="coefficients.html#observation-empirical-approach"><i class="fa fa-check"></i><b>4.4.2</b> Observation-Empirical Approach</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="coefficients.html"><a href="coefficients.html#scaling-to-other-non-normal-distributions"><i class="fa fa-check"></i><b>4.5</b> Scaling to Other Non-Normal Distributions</a></li>
<li class="chapter" data-level="4.6" data-path="coefficients.html"><a href="coefficients.html#references-2"><i class="fa fa-check"></i><b>4.6</b> References</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="categorical-variables.html"><a href="categorical-variables.html"><i class="fa fa-check"></i><b>5</b> Categorical Variables</a><ul>
<li class="chapter" data-level="5.1" data-path="categorical-variables.html"><a href="categorical-variables.html#introduction-to-exogenous-categorical-variables"><i class="fa fa-check"></i><b>5.1</b> Introduction to Exogenous Categorical Variables</a></li>
<li class="chapter" data-level="5.2" data-path="categorical-variables.html"><a href="categorical-variables.html#exogenous-categorical-variables-as-marginal-means"><i class="fa fa-check"></i><b>5.2</b> Exogenous Categorical Variables as Marginal Means</a></li>
<li class="chapter" data-level="5.3" data-path="categorical-variables.html"><a href="categorical-variables.html#exogenous-categorical-variables-as-marginal-means-a-worked-example"><i class="fa fa-check"></i><b>5.3</b> Exogenous Categorical Variables as Marginal Means: A Worked Example</a></li>
<li class="chapter" data-level="5.4" data-path="categorical-variables.html"><a href="categorical-variables.html#endogenous-categorical-variables"><i class="fa fa-check"></i><b>5.4</b> Endogenous Categorical Variables</a></li>
<li class="chapter" data-level="5.5" data-path="categorical-variables.html"><a href="categorical-variables.html#references-3"><i class="fa fa-check"></i><b>5.5</b> References</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html"><i class="fa fa-check"></i><b>6</b> Multigroup Analysis</a><ul>
<li class="chapter" data-level="6.1" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#introduction-to-multigroup-analysis"><i class="fa fa-check"></i><b>6.1</b> Introduction to Multigroup Analysis</a></li>
<li class="chapter" data-level="6.2" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#multigroup-analysis-using-global-estimation"><i class="fa fa-check"></i><b>6.2</b> Multigroup Analysis using Global Estimation</a></li>
<li class="chapter" data-level="6.3" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#multigroup-analysis-using-local-estimation"><i class="fa fa-check"></i><b>6.3</b> Multigroup Analysis Using Local Estimation</a></li>
<li class="chapter" data-level="6.4" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#grace-jutila-1999-a-worked-example"><i class="fa fa-check"></i><b>6.4</b> Grace &amp; Jutila (1999): A Worked Example</a></li>
<li class="chapter" data-level="6.5" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#references-4"><i class="fa fa-check"></i><b>6.5</b> References</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html"><i class="fa fa-check"></i><b>7</b> Latent Variable Modeling</a><ul>
<li class="chapter" data-level="7.1" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#introduction-to-latent-variable-modeling"><i class="fa fa-check"></i><b>7.1</b> Introduction to Latent Variable Modeling</a></li>
<li class="chapter" data-level="7.2" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#application-of-latent-variables-to-path-models"><i class="fa fa-check"></i><b>7.2</b> Application of Latent Variables to Path Models</a></li>
<li class="chapter" data-level="7.3" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#latent-variables-in-lavaan"><i class="fa fa-check"></i><b>7.3</b> Latent Variables in <em>lavaan</em></a></li>
<li class="chapter" data-level="7.4" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#multi-indicator-latent-variables"><i class="fa fa-check"></i><b>7.4</b> Multi-indicator Latent Variables</a></li>
<li class="chapter" data-level="7.5" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#confirmatory-factor-analysis"><i class="fa fa-check"></i><b>7.5</b> Confirmatory Factor Analysis</a></li>
<li class="chapter" data-level="7.6" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#travis-grace-2010-an-example"><i class="fa fa-check"></i><b>7.6</b> Travis &amp; Grace (2010): An Example</a></li>
<li class="chapter" data-level="7.7" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#references-5"><i class="fa fa-check"></i><b>7.7</b> References</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="composite-variables.html"><a href="composite-variables.html"><i class="fa fa-check"></i><b>8</b> Composite Variables</a><ul>
<li class="chapter" data-level="8.1" data-path="composite-variables.html"><a href="composite-variables.html#what-is-a-composite-variable"><i class="fa fa-check"></i><b>8.1</b> What is a Composite Variable?</a></li>
<li class="chapter" data-level="8.2" data-path="composite-variables.html"><a href="composite-variables.html#constructing-a-composite-variable"><i class="fa fa-check"></i><b>8.2</b> Constructing a Composite Variable</a></li>
<li class="chapter" data-level="8.3" data-path="composite-variables.html"><a href="composite-variables.html#grace-keeley-revisited-a-worked-example"><i class="fa fa-check"></i><b>8.3</b> Grace &amp; Keeley Revisited: A Worked Example</a></li>
<li class="chapter" data-level="8.4" data-path="composite-variables.html"><a href="composite-variables.html#composites-in-piecewisesem"><i class="fa fa-check"></i><b>8.4</b> Composites in <em>piecewiseSEM</em></a></li>
<li class="chapter" data-level="8.5" data-path="composite-variables.html"><a href="composite-variables.html#references-6"><i class="fa fa-check"></i><b>8.5</b> References</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Structural Equation Modeling in R for Ecology and Evolution</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="coefficients" class="section level1">
<h1><span class="header-section-number">4</span> Coefficients</h1>
<div id="unstandardized-and-standardized-coefficients" class="section level2">
<h2><span class="header-section-number">4.1</span> Unstandardized and Standardized Coefficients</h2>
<p>Path (or regression) coefficients are the inferential engine behind structural equation modeling, and by extension all of linear regression. They relate changes in the dependent variable <span class="math inline">\(y\)</span> to changes in the independent variable <span class="math inline">\(x\)</span>, and thus act as a measure of association. In fact, you may recall from the chapter on global estimation that, under some circumstances, path coefficients can be expressed as (partial) correlations, a unitless measure of association that makes them excellent for comparisons. They also allow us to generate predictions for new values of <span class="math inline">\(x\)</span> and are therefore useful in testing and extrapolating model results.</p>
<p>We will consider two kinds of regression coefficients: unstandardized (or raw) coefficients, and standardized coefficients.</p>
<p>Unstandardized coefficients are the default values returned by all statistical programs. In short, they reflect the expected (linear) change in the response with each unit change in the predictor. For a coefficient value <span class="math inline">\(\beta = 0.5\)</span>, for example, a 1 unit change in <span class="math inline">\(x\)</span> is, on average, an 0.5 unit change in <span class="math inline">\(y\)</span>.</p>
<p>In models with more than one independent variable (e.g., <span class="math inline">\(x1\)</span>, <span class="math inline">\(x2\)</span>, etc), the coefficient reflects the expected change in <span class="math inline">\(y\)</span> <em>given</em> the other variables in the model. This implies that the effect of one particular variable controls for the presence of other variables, generally by holding them constant at their mean. This is why such coefficients are referred to as <em>partial</em> regression coefficients, because they reflect the independent (or partial) contributions of any particular variable.</p>
<p>As an aside: one tricky aspect to interpretation involves transformations. When the log-transformation is applied, for example, the relationships between the variable are no longer linear. This means that we have to change our interpretation slightly. When <span class="math inline">\(y\)</span> is log-transformed, the coefficient <span class="math inline">\(\beta\)</span> is interpreted as a 1 unit change in <span class="math inline">\(x\)</span> leads to a <span class="math inline">\((exp(\beta) - 1) \times 100%\)</span> change in <span class="math inline">\(y\)</span>. Oppositely, when the independent variable <span class="math inline">\(x\)</span> is log-transformed, <span class="math inline">\(\beta\)</span> is interpreted as a 1% change in <span class="math inline">\(x\)</span> leads to a <span class="math inline">\(\beta\)</span> change in <span class="math inline">\(y\)</span>. Finally, when both are transformed, both are expressed in percentages: a 1% change in <span class="math inline">\(x\)</span> leads to a <span class="math inline">\((exp(\beta) - 1) \times 100%\)</span> change in <span class="math inline">\(y\)</span>. Transformations often confound interpretation, so it is worth mentioning.</p>
<p>In contrast to raw coefficients, standardized coefficients are expressed in equivalent units, regardless of the original measurements. Often these are in units of standard deviations of the mean (scale standardization) but, as we shall see shortly, there are other possibilities. The goal of standardization is to increase <em>comparability</em>. In other words, the magnitude of standardized coefficients can be directly compared to make inferences about the relative strength of relationships.</p>
<p>In SEM, it is often advised to report both unstandardized and standardized coefficients, because they present different and mutually exclusive information. Unstandardized coefficients contain information about both the variance <em>and</em> the mean, and thus are essential for prediction. Along these lines, they are also useful for comparing across models fit to the same variables, but using different sets of data. Because the most common form of standardization involves scaling by the sample standard deviations, data derived from different sources (i.e., different datasets) have different sample variances and their standardized coefficients are not immediately comparable.</p>
<p>Unstandardized coefficients also reflect the phenomenon of interest in straightforward language. Imagine telling someone that 1 standard deviation change in nutrient input levels would result in a 6 standard deviation change in water quality. That might seem impressive until it becomes clear that the size of the dataset has reduced the sample variance, and the absolute relationship reveals only a very tiny change in water quality with each unit change in nutrient levels. Not so impressive anymore.</p>
<p>Standardized effects, on the other hand, are useful for comparing the relative magnitude of change associated with different paths in the same model (i.e., using data drawn frmo the same population). Care should be taken <em>not</em> to interpret these relationships as the ‘proportion of variance explained’–for example, a larger standardized coefficient does not explain more variance in the response than a smaller standardized coefficient–but rather in terms of relative influence on the mean of the response.</p>
<p>By extension, standardization is necessary to compare indirect or compound effects among different sets of paths in the same model: for example, comparing direct vs. indirect pathways in a partial mediation model. This is because those pathways can and often are measured in very different units, and their relative magnitudes might simply reflect their measurement units rather than any stronger or weaker effects.</p>
<p>In contrast, comparing the strength of indirect or compound effects across the same set of variables in different models <em>requires</em> unstandardized coefficients, due to the issue of different sample variances raised above. Comparing the same path across different models using standardized coefficients would require a demonstration that the sample variances are not significantly different (or alternately, that the entire population has been sampled).</p>
<p>Thus, both standardized and unstandardized coefficients have their place in structural equation modeling. Let’s now explore some of the different forms of standardization, and how they can be achieved.</p>
</div>
<div id="scale-standardization" class="section level2">
<h2><span class="header-section-number">4.2</span> Scale Standardization</h2>
<p>The most typical implementation of standardization is placing the coefficients in units of standard deviations of the mean. This is accomplished by scaling the coefficient <span class="math inline">\(\beta\)</span> by the ratio of the standard deviation of <span class="math inline">\(x\)</span> over the standard deviation of <span class="math inline">\(y\)</span>:</p>
<p><span class="math display">\[b = \beta*\left( \frac{sd_x}{sd_y} \right)\]</span></p>
<p>This coefficient has the following interpretation: for a 1 standard deviation change in <span class="math inline">\(x\)</span>, we expect a <span class="math inline">\(b\)</span> unit standard deviation change in <span class="math inline">\(y\)</span>.</p>
<p>This standardization can also be achieved by <em>Z</em>-transforming the raw data, in which case <span class="math inline">\(b\)</span> is already the (partial) correlation between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<p>Both <em>lavaan</em> and <em>piecewiseSEM</em> return scale-standardized coefficients. <em>lavaan</em> requires a different set of functions or arguments, while <em>piecewiseSEM</em> will do it by default using the functions <code>coefs</code>. <code>coefs</code> has the added benefit in that it can be called on any model object, and thus has applications outside of structural equation modeling.</p>
<p>Let’s run an example:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb186-1"><a href="coefficients.html#cb186-1"></a><span class="kw">library</span>(lavaan)</span>
<span id="cb186-2"><a href="coefficients.html#cb186-2"></a><span class="kw">library</span>(piecewiseSEM)</span>
<span id="cb186-3"><a href="coefficients.html#cb186-3"></a></span>
<span id="cb186-4"><a href="coefficients.html#cb186-4"></a><span class="kw">set.seed</span>(<span class="dv">6</span>)</span>
<span id="cb186-5"><a href="coefficients.html#cb186-5"></a></span>
<span id="cb186-6"><a href="coefficients.html#cb186-6"></a>data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">y =</span> <span class="kw">runif</span>(<span class="dv">100</span>), <span class="dt">x =</span> <span class="kw">runif</span>(<span class="dv">100</span>))</span>
<span id="cb186-7"><a href="coefficients.html#cb186-7"></a></span>
<span id="cb186-8"><a href="coefficients.html#cb186-8"></a>xy_model &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> data)</span>
<span id="cb186-9"><a href="coefficients.html#cb186-9"></a></span>
<span id="cb186-10"><a href="coefficients.html#cb186-10"></a><span class="co"># perform manual standardization</span></span>
<span id="cb186-11"><a href="coefficients.html#cb186-11"></a>beta &lt;-<span class="st"> </span><span class="kw">summary</span>(xy_model)<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb186-12"><a href="coefficients.html#cb186-12"></a></span>
<span id="cb186-13"><a href="coefficients.html#cb186-13"></a>(beta_std &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>(<span class="kw">sd</span>(data<span class="op">$</span>x)<span class="op">/</span><span class="kw">sd</span>(data<span class="op">$</span>y)))</span></code></pre></div>
<pre><code>## [1] 0.09456659</code></pre>
<p>For this example, we recover a standardized coefficient of <span class="math inline">\(b = 0.095\)</span>, suggesting that for a 1 standard deviation change in <span class="math inline">\(x\)</span>, there is expectde to be a 0.095 standard deviation change in <span class="math inline">\(y\)</span>.</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb188-1"><a href="coefficients.html#cb188-1"></a><span class="co"># now retrieve with piecewiseSEM</span></span>
<span id="cb188-2"><a href="coefficients.html#cb188-2"></a><span class="kw">coefs</span>(xy_model)<span class="op">$</span>Std.Estimate</span></code></pre></div>
<pre><code>## [1] 0.0946</code></pre>
<p>We get the same estimate from <em>piecewiseSEM</em> using <code>coefs</code>.</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb190-1"><a href="coefficients.html#cb190-1"></a><span class="co"># and with lavaan</span></span>
<span id="cb190-2"><a href="coefficients.html#cb190-2"></a>xy_formula &lt;-<span class="st"> &#39;y ~ x&#39;</span></span>
<span id="cb190-3"><a href="coefficients.html#cb190-3"></a></span>
<span id="cb190-4"><a href="coefficients.html#cb190-4"></a>xy_sem &lt;-<span class="st"> </span><span class="kw">sem</span>(xy_formula, data)</span>
<span id="cb190-5"><a href="coefficients.html#cb190-5"></a></span>
<span id="cb190-6"><a href="coefficients.html#cb190-6"></a><span class="kw">standardizedsolution</span>(xy_sem)<span class="op">$</span>est.std[<span class="dv">1</span>]</span></code></pre></div>
<pre><code>## [1] 0.09456659</code></pre>
<p>And the same for <em>lavaan</em>, demonstrating that these packages use the same scaling procedure under the hood.</p>
</div>
<div id="range-standardization" class="section level2">
<h2><span class="header-section-number">4.3</span> Range Standardization</h2>
<p>An alternative to scale standardization is <em>relevant range</em> standardization. This approach scales the coefficients over some relevant range. Typically this is the full range of the data, in which case <span class="math inline">\(\beta\)</span> can be standardized as follows:</p>
<p><span class="math display">\[b = \beta * \frac{max(x) - min(x)}{max(y) - min(y)}\]</span></p>
<p>The interpretation for the coefficient would then be the expected proportional shift in <span class="math inline">\(y\)</span> along its range given a full shift along the range of <span class="math inline">\(x\)</span>.</p>
<p>At first, this might seem like a strange form of standardization, but it has some powerful applications. For example, consider a binary predictor: 0 or 1. In such a case, the relevant range-standardized coefficient is the expected shift in <span class="math inline">\(y\)</span> given the transition from one state (0) to another (1). Or consider a management target such as decreasing nutrient runoff by 10%. Would reducing fertilizer application by 10% of its range yield a similar reduction in runoff? Such expressions are necessarily the currency of applied questions.</p>
<p>Perhaps the best application of relevant ranges is in comparing coefficients within a model: rather than dealing in somewhat esoteric quantities of standard deviations, relevant range standardization simply asks which variable causes a greater shift in <span class="math inline">\(y\)</span> along its range. This is a much more digestable concept to most scientists. It may even provide a more fair comparison across the same paths fit to different datasets, if the ranges are roughly similar and/or encompassed in the others. Restricting the range may be a useful solution for comparing coefficients across models fit to different data, as long as the range doesn’t extend beyond that observed in any particular dataset.</p>
<p>Note that the decomposition of (partial) correlations as shown in the chapter on global estimation is not possible with relevant ranges, so range standardization is not recommended if the objective to compute indirect or total effects.</p>
<p>For a worked example, we have now entered fully into the realm of <em>piecewiseSEM</em>–it does not appear as if <em>lavaan</em> has integrated this functionality a of yet. Let’s attempt to scale the results by hand, then compare to the output from <code>coefs</code> with the argument <code>standardize = "range"</code>:</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb192-1"><a href="coefficients.html#cb192-1"></a><span class="co">#by hand</span></span>
<span id="cb192-2"><a href="coefficients.html#cb192-2"></a>(beta_rr &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>(<span class="kw">max</span>(data<span class="op">$</span>x) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(data<span class="op">$</span>x))<span class="op">/</span>(<span class="kw">max</span>(data<span class="op">$</span>y) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(data<span class="op">$</span>y)))</span></code></pre></div>
<pre><code>## [1] 0.09806703</code></pre>
<div class="sourceCode" id="cb194"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb194-1"><a href="coefficients.html#cb194-1"></a><span class="kw">coefs</span>(xy_model, <span class="dt">standardize =</span> <span class="st">&quot;range&quot;</span>)<span class="op">$</span>Std.Estimate</span></code></pre></div>
<pre><code>## [1] 0.0981</code></pre>
<p>In both cases, we obtain a <span class="math inline">\(b = 0.098\)</span> suggesting that a full shift in <span class="math inline">\(x\)</span> along its range would only result in a predicted shift of about 10% along the range of <span class="math inline">\(y\)</span>.</p>
<p>Both scale and relevant range-standardization only apply when the response is normally-distributed. If not, we must make some assumptions in order to obtain standardized coefficients. Let’s start with binomial responses, which are the trickiest case.</p>
</div>
<div id="binomial-response-models" class="section level2">
<h2><span class="header-section-number">4.4</span> Binomial Response Models</h2>
<p>Binomial responses are those that are binary (0, 1) such as success or failure, or present vs. absent. What is unique about them is that they do not have a linear relationship with a predictor <span class="math inline">\(x\)</span>. Instead, they are best modeled using a sigmoidal curve. To demonstrate, let’s generate some data, fit a binary model, and plot the predicted relationship:</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb196-1"><a href="coefficients.html#cb196-1"></a><span class="kw">set.seed</span>(<span class="dv">44</span>)</span>
<span id="cb196-2"><a href="coefficients.html#cb196-2"></a></span>
<span id="cb196-3"><a href="coefficients.html#cb196-3"></a>x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">20</span>)</span>
<span id="cb196-4"><a href="coefficients.html#cb196-4"></a></span>
<span id="cb196-5"><a href="coefficients.html#cb196-5"></a>x &lt;-<span class="st"> </span>x[<span class="kw">order</span>(x)]</span>
<span id="cb196-6"><a href="coefficients.html#cb196-6"></a></span>
<span id="cb196-7"><a href="coefficients.html#cb196-7"></a>y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rbinom</span>(<span class="dv">10</span>, <span class="dv">1</span>, <span class="fl">0.8</span>), <span class="kw">rbinom</span>(<span class="dv">10</span>, <span class="dv">1</span>, <span class="fl">0.2</span>))</span>
<span id="cb196-8"><a href="coefficients.html#cb196-8"></a></span>
<span id="cb196-9"><a href="coefficients.html#cb196-9"></a>glm_model &lt;-<span class="st"> </span><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> <span class="kw">data.frame</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y), <span class="st">&quot;binomial&quot;</span>)</span>
<span id="cb196-10"><a href="coefficients.html#cb196-10"></a></span>
<span id="cb196-11"><a href="coefficients.html#cb196-11"></a>xpred &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(x), <span class="kw">max</span>(x), <span class="fl">0.01</span>)</span>
<span id="cb196-12"><a href="coefficients.html#cb196-12"></a></span>
<span id="cb196-13"><a href="coefficients.html#cb196-13"></a>ypred &lt;-<span class="st"> </span><span class="kw">predict</span>(glm_model, <span class="kw">list</span>(<span class="dt">x =</span> xpred), <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>)</span>
<span id="cb196-14"><a href="coefficients.html#cb196-14"></a></span>
<span id="cb196-15"><a href="coefficients.html#cb196-15"></a><span class="kw">plot</span>(x, y)</span>
<span id="cb196-16"><a href="coefficients.html#cb196-16"></a></span>
<span id="cb196-17"><a href="coefficients.html#cb196-17"></a><span class="kw">lines</span>(xpred, ypred)</span></code></pre></div>
<p><img src="04-Coefficients_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>Clearly these data are not linear, and modeling them as such would ignore the underlying data-generating process. Instead, as you can see, we fit them to a binomial distribution using a generalized linear model (GLM).</p>
<p>GLMs consist of three parts: (1) the random component, or the expected values of the response based on their underlying distribution, (2) the systematic component that represents the linear combination of predictors, and (3) the link function, which links the expected values of the response (random component) to the linear combination of predictors (systematic component) via a transformation.</p>
<p>Basically, the link functions take something inherently non-linear and attempts to linearize it. This can be shown by plotting the predictions on the link-scale:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb197-1"><a href="coefficients.html#cb197-1"></a>ypred_link &lt;-<span class="st"> </span><span class="kw">predict</span>(glm_model, <span class="kw">list</span>(<span class="dt">x =</span> xpred), <span class="dt">type =</span> <span class="st">&quot;link&quot;</span>)</span>
<span id="cb197-2"><a href="coefficients.html#cb197-2"></a></span>
<span id="cb197-3"><a href="coefficients.html#cb197-3"></a><span class="kw">plot</span>(xpred, ypred_link)</span></code></pre></div>
<p><img src="04-Coefficients_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Note how the line is no longer sigmoidal, but straight!</p>
<p>For binomial responses, there are two kinds of link functions: logit and probit. We’ll focus on the logit link for now because it’s more common. With this link, the coefficients are in units of logits or the <em>log odds ratio</em>, which reflect the log of the probability of observing an outcome (1) relative to the probability of not observing it (0).</p>
<p>Often these coefficients are reverted to just the odds ratio by taking the exponent, which yields the proportional change in the probablity observing one outcome (1) with a unit change change in the predictor.</p>
<p>Say, for example, we have a coefficient <span class="math inline">\(\beta = -0.12\)</span>. A 1 unit change in <span class="math inline">\(x\)</span> would result in <span class="math inline">\(exp(-0.12) = 0.88 \times 100%\)</span> or 88% reduction in the odds of observing the outcome <span class="math inline">\(y\)</span>.</p>
<p>The problem is that (log) odds ratios themselves are not comparable across models. Further, it’s not immediately clear how they might be standardized since the coefficient is reported on the link (linear) scale, while the only variance we can compute is from the raw data, which is on the non-linear scale. Thus, we need to find some sway to obtain estimates of variance on the same linearized scale as the coefficient.</p>
<div id="latent-theoretic-approach" class="section level3">
<h3><span class="header-section-number">4.4.1</span> Latent Theoretic Approach</h3>
<p>One approach is to consider that for every value of <span class="math inline">\(x\)</span>, there is an underlying probability distribution of observing a 0 or a 1 for <span class="math inline">\(y\)</span>. The mean of these distributions is where a particular outcome is <em>most</em> likely. Let’s say at low values of <span class="math inline">\(x\)</span> we observe <span class="math inline">\(y = 0\)</span>, at at high values of <span class="math inline">\(x\)</span> we observe <span class="math inline">\(y = 1\)</span>. If we order <span class="math inline">\(x\)</span>, the mean probabilities give rise to a linear increase in observing <span class="math inline">\(y = 1\)</span> with increasing <span class="math inline">\(x\)</span>. Here is an illustration of this phenomenon (from Long 1997):</p>
<p><img src="https://raw.githubusercontent.com/jslefche/sem_book/master/img/coefficients_latent_propensity.png" /></p>
<p>This linear but latent (i.e., unobserved) variable, which we call <span class="math inline">\(y^*\)</span>, is therefore related to the observed values of <span class="math inline">\(x\)</span> through a vector of linear coefficients <span class="math inline">\(\beta\)</span> as in any other linear model:</p>
<p><span class="math display">\[y^*_{i} = x_{i}\beta + \epsilon_{i}\]</span></p>
<p>Generally, the linear <span class="math inline">\(y^*\)</span> is related to the non-linear <span class="math inline">\(y\)</span> via a cutpoint, which is generally <span class="math inline">\(\tau = 0.5\)</span> where any value of <span class="math inline">\(x\)</span> where <span class="math inline">\(y^*\)</span>&gt;0.5 is equivalent to <span class="math inline">\(y\)</span> = 1, and any value of <span class="math inline">\(x\)</span> where <span class="math inline">\(y^*\)</span>&lt;0.5 is equivalent to <span class="math inline">\(y\)</span> = 0.</p>
<p>The problem is we can never observe this linear underlying or <em>latent propensity</em> and so we must approximate its error variance. In a later chapter on Latent Variable Modeling, we often fixed their error variance to 1. In this case, there are theoretically-derived error variances depending on the distribution and the link function: for the probit link, the error variance <span class="math inline">\(\epsilon = 1\)</span>, while for the logit link, <span class="math inline">\(\epsilon = \pi^2/3\)</span>, both for the binomial distribution.</p>
<p>Regardless of the type of standardization, we need to know about the range or variance of the response. With our knowledge of <span class="math inline">\(y^*_{i}\)</span> and the theoretical error variances, we have all the information needed to compute the variance on the link (linear) scale.</p>
<p>The variance in <span class="math inline">\(y^*\)</span> is the sum of the variance of the linear (link-transformed) predictions <em>plus</em> the theoretical error variance. For a logit link, then:</p>
<p><span class="math display">\[\sigma_{y^*_{i}}^2 = \sigma_{x\beta}^2 + \pi^2/3\]</span></p>
<p>The square-root of this quantity gives the standard deviation of <span class="math inline">\(SD_{y^*}\)</span> on the linear scale for use in scale standardization, or alternately, the range of <span class="math inline">\(y^*\)</span> to use in relevant range standardization.</p>
</div>
<div id="observation-empirical-approach" class="section level3">
<h3><span class="header-section-number">4.4.2</span> Observation-Empirical Approach</h3>
<p>There is an alternate method which relies on the proportion of variance explained, or <span class="math inline">\(R^2\)</span>. Here, we can express the <span class="math inline">\(R^2\)</span> as the ratio of the variance of the predicted values (on the linear scale) over the variance of the observed values (on the non-linear scale):</p>
<p><span class="math display">\[R^2 = \frac{\sigma_{\hat{y}}^2}{\sigma_{y}^2}\]</span></p>
<p>We can compute <span class="math inline">\(R\)</span>, which is the correlation between the non-linear observed and predicted values on the non-linear scale that, when taken to the power of 2, yields <span class="math inline">\(R^2\)</span>. If we also know the variance of the predicted values on the non-linear scale <span class="math inline">\(y\)</span>, we have all the information to solve for <span class="math inline">\(\sigma_{\hat{y}}\)</span>, whose square-root is the standard deviation of <span class="math inline">\(y\)</span> that we can use in the calculation of the standardized coefficient.</p>
<p>This method, called the <em>observation-empirical approach</em>, does not require the acknowledgement of any latent variables or theoretical error variances, but does require an acceptance of this is a valid measurement of <span class="math inline">\(R^2\)</span> (which some consider it not, as GLM estimation is based on deviance, not variance, and thus this statistic is not equivalent). It also does not provide a measure of the range of <span class="math inline">\(y\)</span> although we can assume, againbased on sampling theory, that <span class="math inline">\(6 * \sigma_{y}\)</span> encompasses the full range of <span class="math inline">\(y\)</span>.</p>
<p>Let’s revisit our earlier GLM example and construct standardized coefficients:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb198-1"><a href="coefficients.html#cb198-1"></a><span class="co"># get beta from model</span></span>
<span id="cb198-2"><a href="coefficients.html#cb198-2"></a>beta &lt;-<span class="st"> </span><span class="kw">summary</span>(glm_model)<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb198-3"><a href="coefficients.html#cb198-3"></a></span>
<span id="cb198-4"><a href="coefficients.html#cb198-4"></a>preds &lt;-<span class="st"> </span><span class="kw">predict</span>(glm_model, <span class="dt">type =</span> <span class="st">&quot;link&quot;</span>) <span class="co"># linear predictions</span></span>
<span id="cb198-5"><a href="coefficients.html#cb198-5"></a></span>
<span id="cb198-6"><a href="coefficients.html#cb198-6"></a><span class="co"># latent theoretic</span></span>
<span id="cb198-7"><a href="coefficients.html#cb198-7"></a>sd.ystar &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(preds) <span class="op">+</span><span class="st"> </span>(pi<span class="op">^</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">3</span>) <span class="co"># for default logit-link</span></span>
<span id="cb198-8"><a href="coefficients.html#cb198-8"></a></span>
<span id="cb198-9"><a href="coefficients.html#cb198-9"></a>beta_lt &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span><span class="kw">sd</span>(x)<span class="op">/</span>sd.ystar</span>
<span id="cb198-10"><a href="coefficients.html#cb198-10"></a></span>
<span id="cb198-11"><a href="coefficients.html#cb198-11"></a><span class="co"># observation empirical</span></span>
<span id="cb198-12"><a href="coefficients.html#cb198-12"></a>R2 &lt;-<span class="st"> </span><span class="kw">cor</span>(y, <span class="kw">predict</span>(glm_model, <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>))<span class="op">^</span><span class="dv">2</span> <span class="co"># non-linear predictions</span></span>
<span id="cb198-13"><a href="coefficients.html#cb198-13"></a></span>
<span id="cb198-14"><a href="coefficients.html#cb198-14"></a>sd.yhat &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(preds)<span class="op">/</span>R2)</span>
<span id="cb198-15"><a href="coefficients.html#cb198-15"></a></span>
<span id="cb198-16"><a href="coefficients.html#cb198-16"></a>beta_oe &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span><span class="kw">sd</span>(x)<span class="op">/</span>sd.yhat</span>
<span id="cb198-17"><a href="coefficients.html#cb198-17"></a></span>
<span id="cb198-18"><a href="coefficients.html#cb198-18"></a><span class="co"># obtain using `coefs`</span></span>
<span id="cb198-19"><a href="coefficients.html#cb198-19"></a><span class="kw">coefs</span>(glm_model, <span class="dt">standardize.type =</span> <span class="st">&quot;latent.linear&quot;</span>); beta_lt</span></code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate  
## 1        y         x  -2.0975    0.9664 18    -2.1703    0.03      -0.8122 *</code></pre>
<pre><code>## [1] -0.8121808</code></pre>
<div class="sourceCode" id="cb201"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb201-1"><a href="coefficients.html#cb201-1"></a><span class="kw">coefs</span>(glm_model, <span class="dt">standardize.type =</span> <span class="st">&quot;Menard.OE&quot;</span>); beta_oe</span></code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate  
## 1        y         x  -2.0975    0.9664 18    -2.1703    0.03      -0.6566 *</code></pre>
<pre><code>## [1] -0.6565602</code></pre>
<p>We see that both approaches produce valid coefficients and they are the same as those returned by the <code>coefs</code> function in <em>piecewiseSEM</em> (with the appropriate argument).</p>
<p>You’ll note that the observation-empirical approach yields a smaller coefficient than the latent-theoretic. This is because the former approach is influenced by the fact that it is based on the relationship between a linear approximation (predictions) of a non-linear variable (raw values), introducing a loss of information. The <em>latent theoretic approach</em> also suffers from a loss of information from use of a distribution-specific but theoretically-derived error variance for binomial distrbutions, which may or may not approach the true error variance (which is unknowable). Either way, both kinds of standardization are not without their drawbacks, but both provide potentially useful information in being able to compare linear and now <em>linearized</em> standardized coefficients for logistic regression.</p>
</div>
</div>
<div id="scaling-to-other-non-normal-distributions" class="section level2">
<h2><span class="header-section-number">4.5</span> Scaling to Other Non-Normal Distributions</h2>
<p>In many ways, logistic regression is the most demanding case for standardization because we are actually modeling a latent (unmeasurable) property whose variance can’t be known (but as explained above, can be estimated). For other distributions, we are modeling the actual values: this means that only the observation-empirical approach can be used, which simplifies the procedure greatly as we don’t need to worry about any theoretical error variances. Let’s work through an example using the Poisson distribution for count data.</p>
<p>The default link function for Poisson models is the log-link, which for our purposes means that we are simply modeling the log of the response. Therefore, we will assume that a generalized linear model fit to a Poisson distribution is approximately the same as a general linear model of the log-transformed response fit to a normal distribution (see papers by Ives and others on this topic). This approximate equivalency will become clear in a moment.</p>
<p>First, let’s create some example Poisson-distributed data:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb204-1"><a href="coefficients.html#cb204-1"></a><span class="kw">set.seed</span>(<span class="dv">100</span>)</span>
<span id="cb204-2"><a href="coefficients.html#cb204-2"></a></span>
<span id="cb204-3"><a href="coefficients.html#cb204-3"></a>count_data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">y =</span> <span class="kw">rpois</span>(<span class="dv">100</span>, <span class="dv">10</span>))</span>
<span id="cb204-4"><a href="coefficients.html#cb204-4"></a></span>
<span id="cb204-5"><a href="coefficients.html#cb204-5"></a>count_data<span class="op">$</span>x &lt;-<span class="st"> </span>count_data<span class="op">$</span>y <span class="op">*</span><span class="st"> </span><span class="kw">runif</span>(<span class="dv">100</span>, <span class="dv">0</span>, <span class="dv">5</span>)</span></code></pre></div>
<p>Now let’s fit an LM with the log-transformed response and see what kind of coefficient we recover:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb205-1"><a href="coefficients.html#cb205-1"></a>lm_model &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(y) <span class="op">~</span><span class="st"> </span>x, count_data)</span>
<span id="cb205-2"><a href="coefficients.html#cb205-2"></a></span>
<span id="cb205-3"><a href="coefficients.html#cb205-3"></a><span class="kw">coefs</span>(lm_model)<span class="op">$</span>Std.Estimate</span></code></pre></div>
<pre><code>## [1] 0.5346</code></pre>
<p>As you may recall from the second rule of path coefficients, the standardized coefficient from a simple linear regression is actually the bivariate correlation between the two:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb207-1"><a href="coefficients.html#cb207-1"></a><span class="kw">with</span>(count_data, <span class="kw">cor</span>(x, <span class="kw">log</span>(y)))</span></code></pre></div>
<pre><code>## [1] 0.5345506</code></pre>
<p>And we see in this example that <span class="math inline">\(b_x = r = 0.54\)</span>.</p>
<p>Now let’s re-fit this model to <span class="math inline">\(y\)</span> using GLM to a Poisson distribution with the default log-link:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb209-1"><a href="coefficients.html#cb209-1"></a>glm_model2 &lt;-<span class="st"> </span><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">family =</span> <span class="kw">poisson</span>(<span class="dt">link =</span> <span class="st">&quot;log&quot;</span>), count_data)</span>
<span id="cb209-2"><a href="coefficients.html#cb209-2"></a></span>
<span id="cb209-3"><a href="coefficients.html#cb209-3"></a><span class="kw">coef</span>(glm_model2)[<span class="dv">2</span>]</span></code></pre></div>
<pre><code>##          x 
## 0.01204693</code></pre>
<p>Here, <span class="math inline">\(\beta_x = 0.012\)</span> which is a bit different from the linear model. That is because the unstandardized coefficient is reported on the link scale.</p>
<p>Let’s repeat our observation-empirical procedure, first by getting the <span class="math inline">\(R^2\)</span> which is the squared correlation between the raw vs. fitted values, then by getting the variance of the raw observations:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb211-1"><a href="coefficients.html#cb211-1"></a>R2 &lt;-<span class="st"> </span><span class="kw">cor</span>(count_data<span class="op">$</span>y, <span class="kw">predict</span>(glm_model2, <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>))<span class="op">^</span><span class="dv">2</span> <span class="co"># non-linear predictions</span></span>
<span id="cb211-2"><a href="coefficients.html#cb211-2"></a></span>
<span id="cb211-3"><a href="coefficients.html#cb211-3"></a>sd.yhat &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(<span class="kw">predict</span>(glm_model2, <span class="dt">type =</span> <span class="st">&quot;link&quot;</span>))<span class="op">/</span>R2)</span>
<span id="cb211-4"><a href="coefficients.html#cb211-4"></a></span>
<span id="cb211-5"><a href="coefficients.html#cb211-5"></a><span class="kw">coef</span>(glm_model2)[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span><span class="kw">sd</span>(count_data<span class="op">$</span>x)<span class="op">/</span>sd.yhat</span></code></pre></div>
<pre><code>##         x 
## 0.5695438</code></pre>
<p>This value of <span class="math inline">\(b_x = 0.57\)</span> from the GLM is remarkably close to the standardized coefficient obtained from the linear model, which was <span class="math inline">\(b_x = 0.54\)</span> and also the correlation between <span class="math inline">\(x\)</span> and <span class="math inline">\(log(y)\)</span>. The differences arise from the fact that for the linear model we have considered the error on <span class="math inline">\(log(y)\)</span> whereas in the GLM, we have only considered the systematic but not the random component. They are generally small enough to be negligible if the data are truly Poisson-distributed. Therefore, we feel comfortable enough reporting the observation-empirical values from the GLM, noting again that they have a slight downward bias due to not incorporating the random component.</p>
<p>Its important to note that by virtue of considering only the the total variance of the fitted values produced by the model, we can extend these methods to hierarchical, mixed, and other models where variance is partitioned or modeled.</p>
<p>For distributions other than Poisson and negative binomial, the procedure becomes trickier. For example, here we assume the variance of the response equals the mean. However, other classes–such as the quasi-distributions–estimate an additional parameter <span class="math inline">\(\phi\)</span> to explain how the variance changes with the mean. As we are interested in quantifying this variance, it is not yet clear how to derive meaningful approximations of <span class="math inline">\(sd_y\)</span> from such distributions. However, we hope to make significant progress on this front in the coming months, so this functionality may be incorporated into the <em>piecewiseSEM</em> package soon.</p>
</div>
<div id="references-2" class="section level2">
<h2><span class="header-section-number">4.6</span> References</h2>
<p>Grace, J. B., Johnson, D. J., Lefcheck, J. S., &amp; Byrnes, J. E. (2018). Quantifying relative importance: computing standardized effects in models with binary outcomes. Ecosphere, 9(6), e02283.</p>
<p>Scott Long, J. (1997). Regression models for categorical and limited dependent variables. Advanced quantitative techniques in the social sciences, 7.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="local-estimation.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="categorical-variables.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
